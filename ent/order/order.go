// Code generated by ent, DO NOT EDIT.

package order

import (
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the order type in the database.
	Label = "order"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldPlacedAt holds the string denoting the placed_at field in the database.
	FieldPlacedAt = "placed_at"
	// FieldBalanceDue holds the string denoting the balance_due field in the database.
	FieldBalanceDue = "balance_due"
	// EdgeCustomer holds the string denoting the customer edge name in mutations.
	EdgeCustomer = "customer"
	// EdgeOrderItems holds the string denoting the order_items edge name in mutations.
	EdgeOrderItems = "order_items"
	// EdgePayments holds the string denoting the payments edge name in mutations.
	EdgePayments = "payments"
	// EdgeProcessedBy holds the string denoting the processed_by edge name in mutations.
	EdgeProcessedBy = "processed_by"
	// Table holds the table name of the order in the database.
	Table = "orders"
	// CustomerTable is the table that holds the customer relation/edge. The primary key declared below.
	CustomerTable = "customer_orders"
	// CustomerInverseTable is the table name for the Customer entity.
	// It exists in this package in order to avoid circular dependency with the "customer" package.
	CustomerInverseTable = "customers"
	// OrderItemsTable is the table that holds the order_items relation/edge. The primary key declared below.
	OrderItemsTable = "order_order_items"
	// OrderItemsInverseTable is the table name for the OrderItem entity.
	// It exists in this package in order to avoid circular dependency with the "orderitem" package.
	OrderItemsInverseTable = "order_items"
	// PaymentsTable is the table that holds the payments relation/edge. The primary key declared below.
	PaymentsTable = "order_payments"
	// PaymentsInverseTable is the table name for the Payment entity.
	// It exists in this package in order to avoid circular dependency with the "payment" package.
	PaymentsInverseTable = "payments"
	// ProcessedByTable is the table that holds the processed_by relation/edge. The primary key declared below.
	ProcessedByTable = "staff_member_processed_orders"
	// ProcessedByInverseTable is the table name for the StaffMember entity.
	// It exists in this package in order to avoid circular dependency with the "staffmember" package.
	ProcessedByInverseTable = "staff_members"
)

// Columns holds all SQL columns for order fields.
var Columns = []string{
	FieldID,
	FieldStatus,
	FieldPlacedAt,
	FieldBalanceDue,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "orders"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"user_orders",
}

var (
	// CustomerPrimaryKey and CustomerColumn2 are the table columns denoting the
	// primary key for the customer relation (M2M).
	CustomerPrimaryKey = []string{"customer_id", "order_id"}
	// OrderItemsPrimaryKey and OrderItemsColumn2 are the table columns denoting the
	// primary key for the order_items relation (M2M).
	OrderItemsPrimaryKey = []string{"order_id", "order_item_id"}
	// PaymentsPrimaryKey and PaymentsColumn2 are the table columns denoting the
	// primary key for the payments relation (M2M).
	PaymentsPrimaryKey = []string{"order_id", "payment_id"}
	// ProcessedByPrimaryKey and ProcessedByColumn2 are the table columns denoting the
	// primary key for the processed_by relation (M2M).
	ProcessedByPrimaryKey = []string{"staff_member_id", "order_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultPlacedAt holds the default value on creation for the "placed_at" field.
	DefaultPlacedAt func() time.Time
	// DefaultBalanceDue holds the default value on creation for the "balance_due" field.
	DefaultBalanceDue float64
	// BalanceDueValidator is a validator for the "balance_due" field. It is called by the builders before save.
	BalanceDueValidator func(float64) error
)

// Status defines the type for the "status" enum field.
type Status string

// StatusPending is the default value of the Status enum.
const DefaultStatus = StatusPending

// Status values.
const (
	StatusPending    Status = "PENDING"
	StatusInProgress Status = "IN_PROGRESS"
	StatusCompleted  Status = "COMPLETED"
	StatusDelivered  Status = "DELIVERED"
	StatusCancelled  Status = "CANCELLED"
	StatusReturned   Status = "RETURNED"
	StatusRefunded   Status = "REFUNDED"
	StatusFailed     Status = "FAILED"
	StatusOnHold     Status = "ON_HOLD"
)

func (s Status) String() string {
	return string(s)
}

// StatusValidator is a validator for the "status" field enum values. It is called by the builders before save.
func StatusValidator(s Status) error {
	switch s {
	case StatusPending, StatusInProgress, StatusCompleted, StatusDelivered, StatusCancelled, StatusReturned, StatusRefunded, StatusFailed, StatusOnHold:
		return nil
	default:
		return fmt.Errorf("order: invalid enum value for status field: %q", s)
	}
}

// OrderOption defines the ordering options for the Order queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByPlacedAt orders the results by the placed_at field.
func ByPlacedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPlacedAt, opts...).ToFunc()
}

// ByBalanceDue orders the results by the balance_due field.
func ByBalanceDue(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBalanceDue, opts...).ToFunc()
}

// ByCustomerCount orders the results by customer count.
func ByCustomerCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newCustomerStep(), opts...)
	}
}

// ByCustomer orders the results by customer terms.
func ByCustomer(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCustomerStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByOrderItemsCount orders the results by order_items count.
func ByOrderItemsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newOrderItemsStep(), opts...)
	}
}

// ByOrderItems orders the results by order_items terms.
func ByOrderItems(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newOrderItemsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByPaymentsCount orders the results by payments count.
func ByPaymentsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newPaymentsStep(), opts...)
	}
}

// ByPayments orders the results by payments terms.
func ByPayments(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPaymentsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByProcessedByCount orders the results by processed_by count.
func ByProcessedByCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newProcessedByStep(), opts...)
	}
}

// ByProcessedBy orders the results by processed_by terms.
func ByProcessedBy(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newProcessedByStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newCustomerStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CustomerInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, CustomerTable, CustomerPrimaryKey...),
	)
}
func newOrderItemsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(OrderItemsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, OrderItemsTable, OrderItemsPrimaryKey...),
	)
}
func newPaymentsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PaymentsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, PaymentsTable, PaymentsPrimaryKey...),
	)
}
func newProcessedByStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ProcessedByInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, ProcessedByTable, ProcessedByPrimaryKey...),
	)
}
