// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/mikestefanello/pagoda/ent/cart"
	"github.com/mikestefanello/pagoda/ent/cartitem"
	"github.com/mikestefanello/pagoda/ent/company"
	"github.com/mikestefanello/pagoda/ent/customer"
	"github.com/mikestefanello/pagoda/ent/order"
	"github.com/mikestefanello/pagoda/ent/orderitem"
	"github.com/mikestefanello/pagoda/ent/passwordtoken"
	"github.com/mikestefanello/pagoda/ent/payment"
	"github.com/mikestefanello/pagoda/ent/predicate"
	"github.com/mikestefanello/pagoda/ent/product"
	"github.com/mikestefanello/pagoda/ent/productcategory"
	"github.com/mikestefanello/pagoda/ent/staffmember"
	"github.com/mikestefanello/pagoda/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCart            = "Cart"
	TypeCartItem        = "CartItem"
	TypeCompany         = "Company"
	TypeCustomer        = "Customer"
	TypeOrder           = "Order"
	TypeOrderItem       = "OrderItem"
	TypePasswordToken   = "PasswordToken"
	TypePayment         = "Payment"
	TypeProduct         = "Product"
	TypeProductCategory = "ProductCategory"
	TypeStaffMember     = "StaffMember"
	TypeUser            = "User"
)

// CartMutation represents an operation that mutates the Cart nodes in the graph.
type CartMutation struct {
	config
	op                Op
	typ               string
	id                *int
	clearedFields     map[string]struct{}
	cart_items        map[int]struct{}
	removedcart_items map[int]struct{}
	clearedcart_items bool
	customer          *int
	clearedcustomer   bool
	done              bool
	oldValue          func(context.Context) (*Cart, error)
	predicates        []predicate.Cart
}

var _ ent.Mutation = (*CartMutation)(nil)

// cartOption allows management of the mutation configuration using functional options.
type cartOption func(*CartMutation)

// newCartMutation creates new mutation for the Cart entity.
func newCartMutation(c config, op Op, opts ...cartOption) *CartMutation {
	m := &CartMutation{
		config:        c,
		op:            op,
		typ:           TypeCart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCartID sets the ID field of the mutation.
func withCartID(id int) cartOption {
	return func(m *CartMutation) {
		var (
			err   error
			once  sync.Once
			value *Cart
		)
		m.oldValue = func(ctx context.Context) (*Cart, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cart.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCart sets the old Cart of the mutation.
func withCart(node *Cart) cartOption {
	return func(m *CartMutation) {
		m.oldValue = func(context.Context) (*Cart, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CartMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CartMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cart.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddCartItemIDs adds the "cart_items" edge to the CartItem entity by ids.
func (m *CartMutation) AddCartItemIDs(ids ...int) {
	if m.cart_items == nil {
		m.cart_items = make(map[int]struct{})
	}
	for i := range ids {
		m.cart_items[ids[i]] = struct{}{}
	}
}

// ClearCartItems clears the "cart_items" edge to the CartItem entity.
func (m *CartMutation) ClearCartItems() {
	m.clearedcart_items = true
}

// CartItemsCleared reports if the "cart_items" edge to the CartItem entity was cleared.
func (m *CartMutation) CartItemsCleared() bool {
	return m.clearedcart_items
}

// RemoveCartItemIDs removes the "cart_items" edge to the CartItem entity by IDs.
func (m *CartMutation) RemoveCartItemIDs(ids ...int) {
	if m.removedcart_items == nil {
		m.removedcart_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cart_items, ids[i])
		m.removedcart_items[ids[i]] = struct{}{}
	}
}

// RemovedCartItems returns the removed IDs of the "cart_items" edge to the CartItem entity.
func (m *CartMutation) RemovedCartItemsIDs() (ids []int) {
	for id := range m.removedcart_items {
		ids = append(ids, id)
	}
	return
}

// CartItemsIDs returns the "cart_items" edge IDs in the mutation.
func (m *CartMutation) CartItemsIDs() (ids []int) {
	for id := range m.cart_items {
		ids = append(ids, id)
	}
	return
}

// ResetCartItems resets all changes to the "cart_items" edge.
func (m *CartMutation) ResetCartItems() {
	m.cart_items = nil
	m.clearedcart_items = false
	m.removedcart_items = nil
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *CartMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CartMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CartMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *CartMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CartMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CartMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the CartMutation builder.
func (m *CartMutation) Where(ps ...predicate.Cart) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CartMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CartMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cart, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CartMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CartMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cart).
func (m *CartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CartMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CartMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Cart field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cart field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CartMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CartMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Cart numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CartMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CartMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cart nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CartMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Cart field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CartMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cart_items != nil {
		edges = append(edges, cart.EdgeCartItems)
	}
	if m.customer != nil {
		edges = append(edges, cart.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cart.EdgeCartItems:
		ids := make([]ent.Value, 0, len(m.cart_items))
		for id := range m.cart_items {
			ids = append(ids, id)
		}
		return ids
	case cart.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcart_items != nil {
		edges = append(edges, cart.EdgeCartItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CartMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cart.EdgeCartItems:
		ids := make([]ent.Value, 0, len(m.removedcart_items))
		for id := range m.removedcart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcart_items {
		edges = append(edges, cart.EdgeCartItems)
	}
	if m.clearedcustomer {
		edges = append(edges, cart.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CartMutation) EdgeCleared(name string) bool {
	switch name {
	case cart.EdgeCartItems:
		return m.clearedcart_items
	case cart.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CartMutation) ClearEdge(name string) error {
	switch name {
	case cart.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown Cart unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CartMutation) ResetEdge(name string) error {
	switch name {
	case cart.EdgeCartItems:
		m.ResetCartItems()
		return nil
	case cart.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown Cart edge %s", name)
}

// CartItemMutation represents an operation that mutates the CartItem nodes in the graph.
type CartItemMutation struct {
	config
	op             Op
	typ            string
	id             *int
	quantity       *int
	addquantity    *int
	clearedFields  map[string]struct{}
	cart           map[int]struct{}
	removedcart    map[int]struct{}
	clearedcart    bool
	product        *int
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*CartItem, error)
	predicates     []predicate.CartItem
}

var _ ent.Mutation = (*CartItemMutation)(nil)

// cartitemOption allows management of the mutation configuration using functional options.
type cartitemOption func(*CartItemMutation)

// newCartItemMutation creates new mutation for the CartItem entity.
func newCartItemMutation(c config, op Op, opts ...cartitemOption) *CartItemMutation {
	m := &CartItemMutation{
		config:        c,
		op:            op,
		typ:           TypeCartItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCartItemID sets the ID field of the mutation.
func withCartItemID(id int) cartitemOption {
	return func(m *CartItemMutation) {
		var (
			err   error
			once  sync.Once
			value *CartItem
		)
		m.oldValue = func(ctx context.Context) (*CartItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CartItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCartItem sets the old CartItem of the mutation.
func withCartItem(node *CartItem) cartitemOption {
	return func(m *CartItemMutation) {
		m.oldValue = func(context.Context) (*CartItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CartItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CartItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CartItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CartItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CartItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *CartItemMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *CartItemMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the CartItem entity.
// If the CartItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartItemMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *CartItemMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *CartItemMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *CartItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// AddCartIDs adds the "cart" edge to the Cart entity by ids.
func (m *CartItemMutation) AddCartIDs(ids ...int) {
	if m.cart == nil {
		m.cart = make(map[int]struct{})
	}
	for i := range ids {
		m.cart[ids[i]] = struct{}{}
	}
}

// ClearCart clears the "cart" edge to the Cart entity.
func (m *CartItemMutation) ClearCart() {
	m.clearedcart = true
}

// CartCleared reports if the "cart" edge to the Cart entity was cleared.
func (m *CartItemMutation) CartCleared() bool {
	return m.clearedcart
}

// RemoveCartIDs removes the "cart" edge to the Cart entity by IDs.
func (m *CartItemMutation) RemoveCartIDs(ids ...int) {
	if m.removedcart == nil {
		m.removedcart = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cart, ids[i])
		m.removedcart[ids[i]] = struct{}{}
	}
}

// RemovedCart returns the removed IDs of the "cart" edge to the Cart entity.
func (m *CartItemMutation) RemovedCartIDs() (ids []int) {
	for id := range m.removedcart {
		ids = append(ids, id)
	}
	return
}

// CartIDs returns the "cart" edge IDs in the mutation.
func (m *CartItemMutation) CartIDs() (ids []int) {
	for id := range m.cart {
		ids = append(ids, id)
	}
	return
}

// ResetCart resets all changes to the "cart" edge.
func (m *CartItemMutation) ResetCart() {
	m.cart = nil
	m.clearedcart = false
	m.removedcart = nil
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *CartItemMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *CartItemMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *CartItemMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *CartItemMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *CartItemMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *CartItemMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the CartItemMutation builder.
func (m *CartItemMutation) Where(ps ...predicate.CartItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CartItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CartItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CartItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CartItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CartItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CartItem).
func (m *CartItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CartItemMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.quantity != nil {
		fields = append(fields, cartitem.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CartItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cartitem.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CartItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cartitem.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown CartItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cartitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown CartItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CartItemMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, cartitem.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CartItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cartitem.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cartitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown CartItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CartItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CartItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CartItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CartItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CartItemMutation) ResetField(name string) error {
	switch name {
	case cartitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown CartItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CartItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cart != nil {
		edges = append(edges, cartitem.EdgeCart)
	}
	if m.product != nil {
		edges = append(edges, cartitem.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CartItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cartitem.EdgeCart:
		ids := make([]ent.Value, 0, len(m.cart))
		for id := range m.cart {
			ids = append(ids, id)
		}
		return ids
	case cartitem.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CartItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcart != nil {
		edges = append(edges, cartitem.EdgeCart)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CartItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cartitem.EdgeCart:
		ids := make([]ent.Value, 0, len(m.removedcart))
		for id := range m.removedcart {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CartItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcart {
		edges = append(edges, cartitem.EdgeCart)
	}
	if m.clearedproduct {
		edges = append(edges, cartitem.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CartItemMutation) EdgeCleared(name string) bool {
	switch name {
	case cartitem.EdgeCart:
		return m.clearedcart
	case cartitem.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CartItemMutation) ClearEdge(name string) error {
	switch name {
	case cartitem.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown CartItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CartItemMutation) ResetEdge(name string) error {
	switch name {
	case cartitem.EdgeCart:
		m.ResetCart()
		return nil
	case cartitem.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown CartItem edge %s", name)
}

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	billing_contact  *string
	billing_email    *string
	billing_phone    *string
	billing_address  *string
	tax_identifier   *string
	clearedFields    map[string]struct{}
	customers        map[int]struct{}
	removedcustomers map[int]struct{}
	clearedcustomers bool
	orders           map[int]struct{}
	removedorders    map[int]struct{}
	clearedorders    bool
	done             bool
	oldValue         func(context.Context) (*Company, error)
	predicates       []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id int) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Company.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// SetBillingContact sets the "billing_contact" field.
func (m *CompanyMutation) SetBillingContact(s string) {
	m.billing_contact = &s
}

// BillingContact returns the value of the "billing_contact" field in the mutation.
func (m *CompanyMutation) BillingContact() (r string, exists bool) {
	v := m.billing_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingContact returns the old "billing_contact" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldBillingContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingContact: %w", err)
	}
	return oldValue.BillingContact, nil
}

// ResetBillingContact resets all changes to the "billing_contact" field.
func (m *CompanyMutation) ResetBillingContact() {
	m.billing_contact = nil
}

// SetBillingEmail sets the "billing_email" field.
func (m *CompanyMutation) SetBillingEmail(s string) {
	m.billing_email = &s
}

// BillingEmail returns the value of the "billing_email" field in the mutation.
func (m *CompanyMutation) BillingEmail() (r string, exists bool) {
	v := m.billing_email
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingEmail returns the old "billing_email" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldBillingEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingEmail: %w", err)
	}
	return oldValue.BillingEmail, nil
}

// ResetBillingEmail resets all changes to the "billing_email" field.
func (m *CompanyMutation) ResetBillingEmail() {
	m.billing_email = nil
}

// SetBillingPhone sets the "billing_phone" field.
func (m *CompanyMutation) SetBillingPhone(s string) {
	m.billing_phone = &s
}

// BillingPhone returns the value of the "billing_phone" field in the mutation.
func (m *CompanyMutation) BillingPhone() (r string, exists bool) {
	v := m.billing_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingPhone returns the old "billing_phone" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldBillingPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingPhone: %w", err)
	}
	return oldValue.BillingPhone, nil
}

// ResetBillingPhone resets all changes to the "billing_phone" field.
func (m *CompanyMutation) ResetBillingPhone() {
	m.billing_phone = nil
}

// SetBillingAddress sets the "billing_address" field.
func (m *CompanyMutation) SetBillingAddress(s string) {
	m.billing_address = &s
}

// BillingAddress returns the value of the "billing_address" field in the mutation.
func (m *CompanyMutation) BillingAddress() (r string, exists bool) {
	v := m.billing_address
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddress returns the old "billing_address" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldBillingAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddress: %w", err)
	}
	return oldValue.BillingAddress, nil
}

// ResetBillingAddress resets all changes to the "billing_address" field.
func (m *CompanyMutation) ResetBillingAddress() {
	m.billing_address = nil
}

// SetTaxIdentifier sets the "tax_identifier" field.
func (m *CompanyMutation) SetTaxIdentifier(s string) {
	m.tax_identifier = &s
}

// TaxIdentifier returns the value of the "tax_identifier" field in the mutation.
func (m *CompanyMutation) TaxIdentifier() (r string, exists bool) {
	v := m.tax_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxIdentifier returns the old "tax_identifier" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldTaxIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxIdentifier: %w", err)
	}
	return oldValue.TaxIdentifier, nil
}

// ResetTaxIdentifier resets all changes to the "tax_identifier" field.
func (m *CompanyMutation) ResetTaxIdentifier() {
	m.tax_identifier = nil
}

// AddCustomerIDs adds the "customers" edge to the Customer entity by ids.
func (m *CompanyMutation) AddCustomerIDs(ids ...int) {
	if m.customers == nil {
		m.customers = make(map[int]struct{})
	}
	for i := range ids {
		m.customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "customers" edge to the Customer entity.
func (m *CompanyMutation) ClearCustomers() {
	m.clearedcustomers = true
}

// CustomersCleared reports if the "customers" edge to the Customer entity was cleared.
func (m *CompanyMutation) CustomersCleared() bool {
	return m.clearedcustomers
}

// RemoveCustomerIDs removes the "customers" edge to the Customer entity by IDs.
func (m *CompanyMutation) RemoveCustomerIDs(ids ...int) {
	if m.removedcustomers == nil {
		m.removedcustomers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customers, ids[i])
		m.removedcustomers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "customers" edge to the Customer entity.
func (m *CompanyMutation) RemovedCustomersIDs() (ids []int) {
	for id := range m.removedcustomers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "customers" edge IDs in the mutation.
func (m *CompanyMutation) CustomersIDs() (ids []int) {
	for id := range m.customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "customers" edge.
func (m *CompanyMutation) ResetCustomers() {
	m.customers = nil
	m.clearedcustomers = false
	m.removedcustomers = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *CompanyMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *CompanyMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *CompanyMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *CompanyMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *CompanyMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *CompanyMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *CompanyMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Company, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	if m.billing_contact != nil {
		fields = append(fields, company.FieldBillingContact)
	}
	if m.billing_email != nil {
		fields = append(fields, company.FieldBillingEmail)
	}
	if m.billing_phone != nil {
		fields = append(fields, company.FieldBillingPhone)
	}
	if m.billing_address != nil {
		fields = append(fields, company.FieldBillingAddress)
	}
	if m.tax_identifier != nil {
		fields = append(fields, company.FieldTaxIdentifier)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldName:
		return m.Name()
	case company.FieldBillingContact:
		return m.BillingContact()
	case company.FieldBillingEmail:
		return m.BillingEmail()
	case company.FieldBillingPhone:
		return m.BillingPhone()
	case company.FieldBillingAddress:
		return m.BillingAddress()
	case company.FieldTaxIdentifier:
		return m.TaxIdentifier()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldName:
		return m.OldName(ctx)
	case company.FieldBillingContact:
		return m.OldBillingContact(ctx)
	case company.FieldBillingEmail:
		return m.OldBillingEmail(ctx)
	case company.FieldBillingPhone:
		return m.OldBillingPhone(ctx)
	case company.FieldBillingAddress:
		return m.OldBillingAddress(ctx)
	case company.FieldTaxIdentifier:
		return m.OldTaxIdentifier(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case company.FieldBillingContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingContact(v)
		return nil
	case company.FieldBillingEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingEmail(v)
		return nil
	case company.FieldBillingPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingPhone(v)
		return nil
	case company.FieldBillingAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddress(v)
		return nil
	case company.FieldTaxIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxIdentifier(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldName:
		m.ResetName()
		return nil
	case company.FieldBillingContact:
		m.ResetBillingContact()
		return nil
	case company.FieldBillingEmail:
		m.ResetBillingEmail()
		return nil
	case company.FieldBillingPhone:
		m.ResetBillingPhone()
		return nil
	case company.FieldBillingAddress:
		m.ResetBillingAddress()
		return nil
	case company.FieldTaxIdentifier:
		m.ResetTaxIdentifier()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.customers != nil {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.orders != nil {
		edges = append(edges, company.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.customers))
		for id := range m.customers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcustomers != nil {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.removedorders != nil {
		edges = append(edges, company.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removedcustomers))
		for id := range m.removedcustomers {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcustomers {
		edges = append(edges, company.EdgeCustomers)
	}
	if m.clearedorders {
		edges = append(edges, company.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeCustomers:
		return m.clearedcustomers
	case company.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeCustomers:
		m.ResetCustomers()
		return nil
	case company.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	email          *string
	password       *string
	address        *string
	status         *customer.Status
	clearedFields  map[string]struct{}
	orders         map[int]struct{}
	removedorders  map[int]struct{}
	clearedorders  bool
	cart           *int
	clearedcart    bool
	company        *int
	clearedcompany bool
	done           bool
	oldValue       func(context.Context) (*Customer, error)
	predicates     []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *CustomerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CustomerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *CustomerMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *CustomerMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *CustomerMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *CustomerMutation) ResetPassword() {
	m.password = nil
}

// SetAddress sets the "address" field.
func (m *CustomerMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CustomerMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *CustomerMutation) ResetAddress() {
	m.address = nil
}

// SetStatus sets the "status" field.
func (m *CustomerMutation) SetStatus(c customer.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CustomerMutation) Status() (r customer.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldStatus(ctx context.Context) (v customer.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CustomerMutation) ResetStatus() {
	m.status = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *CustomerMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *CustomerMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *CustomerMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *CustomerMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *CustomerMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *CustomerMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *CustomerMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// SetCartID sets the "cart" edge to the Cart entity by id.
func (m *CustomerMutation) SetCartID(id int) {
	m.cart = &id
}

// ClearCart clears the "cart" edge to the Cart entity.
func (m *CustomerMutation) ClearCart() {
	m.clearedcart = true
}

// CartCleared reports if the "cart" edge to the Cart entity was cleared.
func (m *CustomerMutation) CartCleared() bool {
	return m.clearedcart
}

// CartID returns the "cart" edge ID in the mutation.
func (m *CustomerMutation) CartID() (id int, exists bool) {
	if m.cart != nil {
		return *m.cart, true
	}
	return
}

// CartIDs returns the "cart" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CartID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) CartIDs() (ids []int) {
	if id := m.cart; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCart resets all changes to the "cart" edge.
func (m *CustomerMutation) ResetCart() {
	m.cart = nil
	m.clearedcart = false
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *CustomerMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *CustomerMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *CustomerMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *CustomerMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CustomerMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.email != nil {
		fields = append(fields, customer.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, customer.FieldPassword)
	}
	if m.address != nil {
		fields = append(fields, customer.FieldAddress)
	}
	if m.status != nil {
		fields = append(fields, customer.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldName:
		return m.Name()
	case customer.FieldEmail:
		return m.Email()
	case customer.FieldPassword:
		return m.Password()
	case customer.FieldAddress:
		return m.Address()
	case customer.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldEmail:
		return m.OldEmail(ctx)
	case customer.FieldPassword:
		return m.OldPassword(ctx)
	case customer.FieldAddress:
		return m.OldAddress(ctx)
	case customer.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customer.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case customer.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case customer.FieldStatus:
		v, ok := value.(customer.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldEmail:
		m.ResetEmail()
		return nil
	case customer.FieldPassword:
		m.ResetPassword()
		return nil
	case customer.FieldAddress:
		m.ResetAddress()
		return nil
	case customer.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.orders != nil {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.cart != nil {
		edges = append(edges, customer.EdgeCart)
	}
	if m.company != nil {
		edges = append(edges, customer.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeCart:
		if id := m.cart; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorders != nil {
		edges = append(edges, customer.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedorders {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.clearedcart {
		edges = append(edges, customer.EdgeCart)
	}
	if m.clearedcompany {
		edges = append(edges, customer.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeOrders:
		return m.clearedorders
	case customer.EdgeCart:
		return m.clearedcart
	case customer.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeCart:
		m.ClearCart()
		return nil
	case customer.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeOrders:
		m.ResetOrders()
		return nil
	case customer.EdgeCart:
		m.ResetCart()
		return nil
	case customer.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	status              *order.Status
	placed_at           *time.Time
	balance_due         *float64
	addbalance_due      *float64
	clearedFields       map[string]struct{}
	customer            map[int]struct{}
	removedcustomer     map[int]struct{}
	clearedcustomer     bool
	order_items         map[int]struct{}
	removedorder_items  map[int]struct{}
	clearedorder_items  bool
	payments            map[int]struct{}
	removedpayments     map[int]struct{}
	clearedpayments     bool
	processed_by        map[int]struct{}
	removedprocessed_by map[int]struct{}
	clearedprocessed_by bool
	company             *int
	clearedcompany      bool
	done                bool
	oldValue            func(context.Context) (*Order, error)
	predicates          []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetPlacedAt sets the "placed_at" field.
func (m *OrderMutation) SetPlacedAt(t time.Time) {
	m.placed_at = &t
}

// PlacedAt returns the value of the "placed_at" field in the mutation.
func (m *OrderMutation) PlacedAt() (r time.Time, exists bool) {
	v := m.placed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlacedAt returns the old "placed_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlacedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlacedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlacedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlacedAt: %w", err)
	}
	return oldValue.PlacedAt, nil
}

// ResetPlacedAt resets all changes to the "placed_at" field.
func (m *OrderMutation) ResetPlacedAt() {
	m.placed_at = nil
}

// SetBalanceDue sets the "balance_due" field.
func (m *OrderMutation) SetBalanceDue(f float64) {
	m.balance_due = &f
	m.addbalance_due = nil
}

// BalanceDue returns the value of the "balance_due" field in the mutation.
func (m *OrderMutation) BalanceDue() (r float64, exists bool) {
	v := m.balance_due
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceDue returns the old "balance_due" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldBalanceDue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceDue: %w", err)
	}
	return oldValue.BalanceDue, nil
}

// AddBalanceDue adds f to the "balance_due" field.
func (m *OrderMutation) AddBalanceDue(f float64) {
	if m.addbalance_due != nil {
		*m.addbalance_due += f
	} else {
		m.addbalance_due = &f
	}
}

// AddedBalanceDue returns the value that was added to the "balance_due" field in this mutation.
func (m *OrderMutation) AddedBalanceDue() (r float64, exists bool) {
	v := m.addbalance_due
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalanceDue resets all changes to the "balance_due" field.
func (m *OrderMutation) ResetBalanceDue() {
	m.balance_due = nil
	m.addbalance_due = nil
}

// AddCustomerIDs adds the "customer" edge to the Customer entity by ids.
func (m *OrderMutation) AddCustomerIDs(ids ...int) {
	if m.customer == nil {
		m.customer = make(map[int]struct{})
	}
	for i := range ids {
		m.customer[ids[i]] = struct{}{}
	}
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *OrderMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *OrderMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// RemoveCustomerIDs removes the "customer" edge to the Customer entity by IDs.
func (m *OrderMutation) RemoveCustomerIDs(ids ...int) {
	if m.removedcustomer == nil {
		m.removedcustomer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer, ids[i])
		m.removedcustomer[ids[i]] = struct{}{}
	}
}

// RemovedCustomer returns the removed IDs of the "customer" edge to the Customer entity.
func (m *OrderMutation) RemovedCustomerIDs() (ids []int) {
	for id := range m.removedcustomer {
		ids = append(ids, id)
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
func (m *OrderMutation) CustomerIDs() (ids []int) {
	for id := range m.customer {
		ids = append(ids, id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *OrderMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
	m.removedcustomer = nil
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddOrderItemIDs(ids ...int) {
	if m.order_items == nil {
		m.order_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *OrderMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *OrderMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveOrderItemIDs(ids ...int) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_items, ids[i])
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *OrderMutation) RemovedOrderItemsIDs() (ids []int) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *OrderMutation) OrderItemsIDs() (ids []int) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *OrderMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// AddPaymentIDs adds the "payments" edge to the Payment entity by ids.
func (m *OrderMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the Payment entity.
func (m *OrderMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the Payment entity was cleared.
func (m *OrderMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the Payment entity by IDs.
func (m *OrderMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the Payment entity.
func (m *OrderMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *OrderMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *OrderMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// AddProcessedByIDs adds the "processed_by" edge to the StaffMember entity by ids.
func (m *OrderMutation) AddProcessedByIDs(ids ...int) {
	if m.processed_by == nil {
		m.processed_by = make(map[int]struct{})
	}
	for i := range ids {
		m.processed_by[ids[i]] = struct{}{}
	}
}

// ClearProcessedBy clears the "processed_by" edge to the StaffMember entity.
func (m *OrderMutation) ClearProcessedBy() {
	m.clearedprocessed_by = true
}

// ProcessedByCleared reports if the "processed_by" edge to the StaffMember entity was cleared.
func (m *OrderMutation) ProcessedByCleared() bool {
	return m.clearedprocessed_by
}

// RemoveProcessedByIDs removes the "processed_by" edge to the StaffMember entity by IDs.
func (m *OrderMutation) RemoveProcessedByIDs(ids ...int) {
	if m.removedprocessed_by == nil {
		m.removedprocessed_by = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.processed_by, ids[i])
		m.removedprocessed_by[ids[i]] = struct{}{}
	}
}

// RemovedProcessedBy returns the removed IDs of the "processed_by" edge to the StaffMember entity.
func (m *OrderMutation) RemovedProcessedByIDs() (ids []int) {
	for id := range m.removedprocessed_by {
		ids = append(ids, id)
	}
	return
}

// ProcessedByIDs returns the "processed_by" edge IDs in the mutation.
func (m *OrderMutation) ProcessedByIDs() (ids []int) {
	for id := range m.processed_by {
		ids = append(ids, id)
	}
	return
}

// ResetProcessedBy resets all changes to the "processed_by" edge.
func (m *OrderMutation) ResetProcessedBy() {
	m.processed_by = nil
	m.clearedprocessed_by = false
	m.removedprocessed_by = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *OrderMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *OrderMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *OrderMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *OrderMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *OrderMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.placed_at != nil {
		fields = append(fields, order.FieldPlacedAt)
	}
	if m.balance_due != nil {
		fields = append(fields, order.FieldBalanceDue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldStatus:
		return m.Status()
	case order.FieldPlacedAt:
		return m.PlacedAt()
	case order.FieldBalanceDue:
		return m.BalanceDue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldPlacedAt:
		return m.OldPlacedAt(ctx)
	case order.FieldBalanceDue:
		return m.OldBalanceDue(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldPlacedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlacedAt(v)
		return nil
	case order.FieldBalanceDue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceDue(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addbalance_due != nil {
		fields = append(fields, order.FieldBalanceDue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldBalanceDue:
		return m.AddedBalanceDue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldBalanceDue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalanceDue(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldPlacedAt:
		m.ResetPlacedAt()
		return nil
	case order.FieldBalanceDue:
		m.ResetBalanceDue()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.customer != nil {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.order_items != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.payments != nil {
		edges = append(edges, order.EdgePayments)
	}
	if m.processed_by != nil {
		edges = append(edges, order.EdgeProcessedBy)
	}
	if m.company != nil {
		edges = append(edges, order.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeCustomer:
		ids := make([]ent.Value, 0, len(m.customer))
		for id := range m.customer {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeProcessedBy:
		ids := make([]ent.Value, 0, len(m.processed_by))
		for id := range m.processed_by {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcustomer != nil {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.removedorder_items != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.removedpayments != nil {
		edges = append(edges, order.EdgePayments)
	}
	if m.removedprocessed_by != nil {
		edges = append(edges, order.EdgeProcessedBy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeCustomer:
		ids := make([]ent.Value, 0, len(m.removedcustomer))
		for id := range m.removedcustomer {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeProcessedBy:
		ids := make([]ent.Value, 0, len(m.removedprocessed_by))
		for id := range m.removedprocessed_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcustomer {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.clearedorder_items {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.clearedpayments {
		edges = append(edges, order.EdgePayments)
	}
	if m.clearedprocessed_by {
		edges = append(edges, order.EdgeProcessedBy)
	}
	if m.clearedcompany {
		edges = append(edges, order.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeCustomer:
		return m.clearedcustomer
	case order.EdgeOrderItems:
		return m.clearedorder_items
	case order.EdgePayments:
		return m.clearedpayments
	case order.EdgeProcessedBy:
		return m.clearedprocessed_by
	case order.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case order.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	case order.EdgePayments:
		m.ResetPayments()
		return nil
	case order.EdgeProcessedBy:
		m.ResetProcessedBy()
		return nil
	case order.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op             Op
	typ            string
	id             *int
	quantity       *int
	addquantity    *int
	unit_price     *string
	clearedFields  map[string]struct{}
	product        map[int]struct{}
	removedproduct map[int]struct{}
	clearedproduct bool
	_order         map[int]struct{}
	removed_order  map[int]struct{}
	cleared_order  bool
	done           bool
	oldValue       func(context.Context) (*OrderItem, error)
	predicates     []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id int) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *OrderItemMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderItemMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *OrderItemMutation) SetUnitPrice(s string) {
	m.unit_price = &s
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *OrderItemMutation) UnitPrice() (r string, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUnitPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *OrderItemMutation) ResetUnitPrice() {
	m.unit_price = nil
}

// AddProductIDs adds the "product" edge to the Product entity by ids.
func (m *OrderItemMutation) AddProductIDs(ids ...int) {
	if m.product == nil {
		m.product = make(map[int]struct{})
	}
	for i := range ids {
		m.product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *OrderItemMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *OrderItemMutation) ProductCleared() bool {
	return m.clearedproduct
}

// RemoveProductIDs removes the "product" edge to the Product entity by IDs.
func (m *OrderItemMutation) RemoveProductIDs(ids ...int) {
	if m.removedproduct == nil {
		m.removedproduct = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product, ids[i])
		m.removedproduct[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "product" edge to the Product entity.
func (m *OrderItemMutation) RemovedProductIDs() (ids []int) {
	for id := range m.removedproduct {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
func (m *OrderItemMutation) ProductIDs() (ids []int) {
	for id := range m.product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *OrderItemMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
	m.removedproduct = nil
}

// AddOrderIDs adds the "order" edge to the Order entity by ids.
func (m *OrderItemMutation) AddOrderIDs(ids ...int) {
	if m._order == nil {
		m._order = make(map[int]struct{})
	}
	for i := range ids {
		m._order[ids[i]] = struct{}{}
	}
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.cleared_order
}

// RemoveOrderIDs removes the "order" edge to the Order entity by IDs.
func (m *OrderItemMutation) RemoveOrderIDs(ids ...int) {
	if m.removed_order == nil {
		m.removed_order = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._order, ids[i])
		m.removed_order[ids[i]] = struct{}{}
	}
}

// RemovedOrder returns the removed IDs of the "order" edge to the Order entity.
func (m *OrderItemMutation) RemovedOrderIDs() (ids []int) {
	for id := range m.removed_order {
		ids = append(ids, id)
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
func (m *OrderItemMutation) OrderIDs() (ids []int) {
	for id := range m._order {
		ids = append(ids, id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
	m.removed_order = nil
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.quantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.unit_price != nil {
		fields = append(fields, orderitem.FieldUnitPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldQuantity:
		return m.Quantity()
	case orderitem.FieldUnitPrice:
		return m.UnitPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitem.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitem.FieldUnitPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitem.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, orderitem.EdgeProduct)
	}
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.product))
		for id := range m.product {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrder:
		ids := make([]ent.Value, 0, len(m._order))
		for id := range m._order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproduct != nil {
		edges = append(edges, orderitem.EdgeProduct)
	}
	if m.removed_order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removedproduct))
		for id := range m.removedproduct {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.removed_order))
		for id := range m.removed_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, orderitem.EdgeProduct)
	}
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeProduct:
		return m.clearedproduct
	case orderitem.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeProduct:
		m.ResetProduct()
		return nil
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// PasswordTokenMutation represents an operation that mutates the PasswordToken nodes in the graph.
type PasswordTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	hash          *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*PasswordToken, error)
	predicates    []predicate.PasswordToken
}

var _ ent.Mutation = (*PasswordTokenMutation)(nil)

// passwordtokenOption allows management of the mutation configuration using functional options.
type passwordtokenOption func(*PasswordTokenMutation)

// newPasswordTokenMutation creates new mutation for the PasswordToken entity.
func newPasswordTokenMutation(c config, op Op, opts ...passwordtokenOption) *PasswordTokenMutation {
	m := &PasswordTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePasswordToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordTokenID sets the ID field of the mutation.
func withPasswordTokenID(id int) passwordtokenOption {
	return func(m *PasswordTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PasswordToken
		)
		m.oldValue = func(ctx context.Context) (*PasswordToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PasswordToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasswordToken sets the old PasswordToken of the mutation.
func withPasswordToken(node *PasswordToken) passwordtokenOption {
	return func(m *PasswordTokenMutation) {
		m.oldValue = func(context.Context) (*PasswordToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PasswordToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHash sets the "hash" field.
func (m *PasswordTokenMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *PasswordTokenMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the PasswordToken entity.
// If the PasswordToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordTokenMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *PasswordTokenMutation) ResetHash() {
	m.hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PasswordTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasswordTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PasswordToken entity.
// If the PasswordToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasswordTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PasswordTokenMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasswordTokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasswordTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PasswordTokenMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasswordTokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasswordTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasswordTokenMutation builder.
func (m *PasswordTokenMutation) Where(ps ...predicate.PasswordToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PasswordToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PasswordToken).
func (m *PasswordTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordTokenMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.hash != nil {
		fields = append(fields, passwordtoken.FieldHash)
	}
	if m.created_at != nil {
		fields = append(fields, passwordtoken.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passwordtoken.FieldHash:
		return m.Hash()
	case passwordtoken.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passwordtoken.FieldHash:
		return m.OldHash(ctx)
	case passwordtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PasswordToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passwordtoken.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case passwordtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PasswordToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PasswordToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PasswordToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordTokenMutation) ResetField(name string) error {
	switch name {
	case passwordtoken.FieldHash:
		m.ResetHash()
		return nil
	case passwordtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PasswordToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passwordtoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passwordtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passwordtoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case passwordtoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordTokenMutation) ClearEdge(name string) error {
	switch name {
	case passwordtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordTokenMutation) ResetEdge(name string) error {
	switch name {
	case passwordtoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordToken edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	amount         *float64
	addamount      *float64
	payment_method *payment.PaymentMethod
	transaction_id *string
	status         *payment.Status
	processed_at   *time.Time
	clearedFields  map[string]struct{}
	_order         map[int]struct{}
	removed_order  map[int]struct{}
	cleared_order  bool
	done           bool
	oldValue       func(context.Context) (*Payment, error)
	predicates     []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id int) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *PaymentMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PaymentMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPaymentMethod sets the "payment_method" field.
func (m *PaymentMutation) SetPaymentMethod(pm payment.PaymentMethod) {
	m.payment_method = &pm
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *PaymentMutation) PaymentMethod() (r payment.PaymentMethod, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldPaymentMethod(ctx context.Context) (v payment.PaymentMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *PaymentMutation) ResetPaymentMethod() {
	m.payment_method = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *PaymentMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *PaymentMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *PaymentMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetStatus sets the "status" field.
func (m *PaymentMutation) SetStatus(pa payment.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentMutation) Status() (r payment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldStatus(ctx context.Context) (v payment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentMutation) ResetStatus() {
	m.status = nil
}

// SetProcessedAt sets the "processed_at" field.
func (m *PaymentMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *PaymentMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldProcessedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *PaymentMutation) ResetProcessedAt() {
	m.processed_at = nil
}

// AddOrderIDs adds the "order" edge to the Order entity by ids.
func (m *PaymentMutation) AddOrderIDs(ids ...int) {
	if m._order == nil {
		m._order = make(map[int]struct{})
	}
	for i := range ids {
		m._order[ids[i]] = struct{}{}
	}
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *PaymentMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *PaymentMutation) OrderCleared() bool {
	return m.cleared_order
}

// RemoveOrderIDs removes the "order" edge to the Order entity by IDs.
func (m *PaymentMutation) RemoveOrderIDs(ids ...int) {
	if m.removed_order == nil {
		m.removed_order = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._order, ids[i])
		m.removed_order[ids[i]] = struct{}{}
	}
}

// RemovedOrder returns the removed IDs of the "order" edge to the Order entity.
func (m *PaymentMutation) RemovedOrderIDs() (ids []int) {
	for id := range m.removed_order {
		ids = append(ids, id)
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
func (m *PaymentMutation) OrderIDs() (ids []int) {
	for id := range m._order {
		ids = append(ids, id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *PaymentMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
	m.removed_order = nil
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.amount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.payment_method != nil {
		fields = append(fields, payment.FieldPaymentMethod)
	}
	if m.transaction_id != nil {
		fields = append(fields, payment.FieldTransactionID)
	}
	if m.status != nil {
		fields = append(fields, payment.FieldStatus)
	}
	if m.processed_at != nil {
		fields = append(fields, payment.FieldProcessedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAmount:
		return m.Amount()
	case payment.FieldPaymentMethod:
		return m.PaymentMethod()
	case payment.FieldTransactionID:
		return m.TransactionID()
	case payment.FieldStatus:
		return m.Status()
	case payment.FieldProcessedAt:
		return m.ProcessedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldAmount:
		return m.OldAmount(ctx)
	case payment.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case payment.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case payment.FieldStatus:
		return m.OldStatus(ctx)
	case payment.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payment.FieldPaymentMethod:
		v, ok := value.(payment.PaymentMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case payment.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case payment.FieldStatus:
		v, ok := value.(payment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case payment.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldAmount:
		m.ResetAmount()
		return nil
	case payment.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case payment.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case payment.FieldStatus:
		m.ResetStatus()
		return nil
	case payment.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, payment.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeOrder:
		ids := make([]ent.Value, 0, len(m._order))
		for id := range m._order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_order != nil {
		edges = append(edges, payment.EdgeOrder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.removed_order))
		for id := range m.removed_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, payment.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	sku                *string
	description        *string
	price              *string
	stock_count        *int
	addstock_count     *int
	image_url          *string
	is_active          *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	cart_items         map[int]struct{}
	removedcart_items  map[int]struct{}
	clearedcart_items  bool
	order_items        map[int]struct{}
	removedorder_items map[int]struct{}
	clearedorder_items bool
	categories         map[int]struct{}
	removedcategories  map[int]struct{}
	clearedcategories  bool
	done               bool
	oldValue           func(context.Context) (*Product, error)
	predicates         []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetSku sets the "sku" field.
func (m *ProductMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *ProductMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *ProductMutation) ResetSku() {
	m.sku = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(s string) {
	m.price = &s
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r string, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
}

// SetStockCount sets the "stock_count" field.
func (m *ProductMutation) SetStockCount(i int) {
	m.stock_count = &i
	m.addstock_count = nil
}

// StockCount returns the value of the "stock_count" field in the mutation.
func (m *ProductMutation) StockCount() (r int, exists bool) {
	v := m.stock_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStockCount returns the old "stock_count" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStockCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStockCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStockCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockCount: %w", err)
	}
	return oldValue.StockCount, nil
}

// AddStockCount adds i to the "stock_count" field.
func (m *ProductMutation) AddStockCount(i int) {
	if m.addstock_count != nil {
		*m.addstock_count += i
	} else {
		m.addstock_count = &i
	}
}

// AddedStockCount returns the value that was added to the "stock_count" field in this mutation.
func (m *ProductMutation) AddedStockCount() (r int, exists bool) {
	v := m.addstock_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStockCount resets all changes to the "stock_count" field.
func (m *ProductMutation) ResetStockCount() {
	m.stock_count = nil
	m.addstock_count = nil
}

// SetImageURL sets the "image_url" field.
func (m *ProductMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *ProductMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *ProductMutation) ResetImageURL() {
	m.image_url = nil
}

// SetIsActive sets the "is_active" field.
func (m *ProductMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ProductMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ProductMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddCartItemIDs adds the "cart_items" edge to the CartItem entity by ids.
func (m *ProductMutation) AddCartItemIDs(ids ...int) {
	if m.cart_items == nil {
		m.cart_items = make(map[int]struct{})
	}
	for i := range ids {
		m.cart_items[ids[i]] = struct{}{}
	}
}

// ClearCartItems clears the "cart_items" edge to the CartItem entity.
func (m *ProductMutation) ClearCartItems() {
	m.clearedcart_items = true
}

// CartItemsCleared reports if the "cart_items" edge to the CartItem entity was cleared.
func (m *ProductMutation) CartItemsCleared() bool {
	return m.clearedcart_items
}

// RemoveCartItemIDs removes the "cart_items" edge to the CartItem entity by IDs.
func (m *ProductMutation) RemoveCartItemIDs(ids ...int) {
	if m.removedcart_items == nil {
		m.removedcart_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cart_items, ids[i])
		m.removedcart_items[ids[i]] = struct{}{}
	}
}

// RemovedCartItems returns the removed IDs of the "cart_items" edge to the CartItem entity.
func (m *ProductMutation) RemovedCartItemsIDs() (ids []int) {
	for id := range m.removedcart_items {
		ids = append(ids, id)
	}
	return
}

// CartItemsIDs returns the "cart_items" edge IDs in the mutation.
func (m *ProductMutation) CartItemsIDs() (ids []int) {
	for id := range m.cart_items {
		ids = append(ids, id)
	}
	return
}

// ResetCartItems resets all changes to the "cart_items" edge.
func (m *ProductMutation) ResetCartItems() {
	m.cart_items = nil
	m.clearedcart_items = false
	m.removedcart_items = nil
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *ProductMutation) AddOrderItemIDs(ids ...int) {
	if m.order_items == nil {
		m.order_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *ProductMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *ProductMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *ProductMutation) RemoveOrderItemIDs(ids ...int) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_items, ids[i])
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *ProductMutation) RemovedOrderItemsIDs() (ids []int) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *ProductMutation) OrderItemsIDs() (ids []int) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *ProductMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// AddCategoryIDs adds the "categories" edge to the ProductCategory entity by ids.
func (m *ProductMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the ProductCategory entity.
func (m *ProductMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the ProductCategory entity was cleared.
func (m *ProductMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the ProductCategory entity by IDs.
func (m *ProductMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the ProductCategory entity.
func (m *ProductMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *ProductMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *ProductMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.sku != nil {
		fields = append(fields, product.FieldSku)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.stock_count != nil {
		fields = append(fields, product.FieldStockCount)
	}
	if m.image_url != nil {
		fields = append(fields, product.FieldImageURL)
	}
	if m.is_active != nil {
		fields = append(fields, product.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldName:
		return m.Name()
	case product.FieldSku:
		return m.Sku()
	case product.FieldDescription:
		return m.Description()
	case product.FieldPrice:
		return m.Price()
	case product.FieldStockCount:
		return m.StockCount()
	case product.FieldImageURL:
		return m.ImageURL()
	case product.FieldIsActive:
		return m.IsActive()
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldSku:
		return m.OldSku(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldStockCount:
		return m.OldStockCount(ctx)
	case product.FieldImageURL:
		return m.OldImageURL(ctx)
	case product.FieldIsActive:
		return m.OldIsActive(ctx)
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldStockCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockCount(v)
		return nil
	case product.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case product.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addstock_count != nil {
		fields = append(fields, product.FieldStockCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldStockCount:
		return m.AddedStockCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldStockCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStockCount(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldSku:
		m.ResetSku()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldStockCount:
		m.ResetStockCount()
		return nil
	case product.FieldImageURL:
		m.ResetImageURL()
		return nil
	case product.FieldIsActive:
		m.ResetIsActive()
		return nil
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cart_items != nil {
		edges = append(edges, product.EdgeCartItems)
	}
	if m.order_items != nil {
		edges = append(edges, product.EdgeOrderItems)
	}
	if m.categories != nil {
		edges = append(edges, product.EdgeCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCartItems:
		ids := make([]ent.Value, 0, len(m.cart_items))
		for id := range m.cart_items {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcart_items != nil {
		edges = append(edges, product.EdgeCartItems)
	}
	if m.removedorder_items != nil {
		edges = append(edges, product.EdgeOrderItems)
	}
	if m.removedcategories != nil {
		edges = append(edges, product.EdgeCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCartItems:
		ids := make([]ent.Value, 0, len(m.removedcart_items))
		for id := range m.removedcart_items {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcart_items {
		edges = append(edges, product.EdgeCartItems)
	}
	if m.clearedorder_items {
		edges = append(edges, product.EdgeOrderItems)
	}
	if m.clearedcategories {
		edges = append(edges, product.EdgeCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeCartItems:
		return m.clearedcart_items
	case product.EdgeOrderItems:
		return m.clearedorder_items
	case product.EdgeCategories:
		return m.clearedcategories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeCartItems:
		m.ResetCartItems()
		return nil
	case product.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	case product.EdgeCategories:
		m.ResetCategories()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductCategoryMutation represents an operation that mutates the ProductCategory nodes in the graph.
type ProductCategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	description     *string
	image_url       *string
	clearedFields   map[string]struct{}
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*ProductCategory, error)
	predicates      []predicate.ProductCategory
}

var _ ent.Mutation = (*ProductCategoryMutation)(nil)

// productcategoryOption allows management of the mutation configuration using functional options.
type productcategoryOption func(*ProductCategoryMutation)

// newProductCategoryMutation creates new mutation for the ProductCategory entity.
func newProductCategoryMutation(c config, op Op, opts ...productcategoryOption) *ProductCategoryMutation {
	m := &ProductCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryID sets the ID field of the mutation.
func withProductCategoryID(id int) productcategoryOption {
	return func(m *ProductCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategory
		)
		m.oldValue = func(ctx context.Context) (*ProductCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategory sets the old ProductCategory of the mutation.
func withProductCategory(node *ProductCategory) productcategoryOption {
	return func(m *ProductCategoryMutation) {
		m.oldValue = func(context.Context) (*ProductCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProductCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductCategoryMutation) ResetDescription() {
	m.description = nil
}

// SetImageURL sets the "image_url" field.
func (m *ProductCategoryMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *ProductCategoryMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *ProductCategoryMutation) ResetImageURL() {
	m.image_url = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ProductCategoryMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductCategoryMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductCategoryMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ProductCategoryMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ProductCategoryMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductCategoryMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductCategoryMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ProductCategoryMutation builder.
func (m *ProductCategoryMutation) Where(ps ...predicate.ProductCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductCategory).
func (m *ProductCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, productcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, productcategory.FieldDescription)
	}
	if m.image_url != nil {
		fields = append(fields, productcategory.FieldImageURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategory.FieldName:
		return m.Name()
	case productcategory.FieldDescription:
		return m.Description()
	case productcategory.FieldImageURL:
		return m.ImageURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategory.FieldName:
		return m.OldName(ctx)
	case productcategory.FieldDescription:
		return m.OldDescription(ctx)
	case productcategory.FieldImageURL:
		return m.OldImageURL(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case productcategory.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryMutation) ResetField(name string) error {
	switch name {
	case productcategory.FieldName:
		m.ResetName()
		return nil
	case productcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case productcategory.FieldImageURL:
		m.ResetImageURL()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, productcategory.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcategory.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, productcategory.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcategory.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, productcategory.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case productcategory.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryMutation) ResetEdge(name string) error {
	switch name {
	case productcategory.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory edge %s", name)
}

// StaffMemberMutation represents an operation that mutates the StaffMember nodes in the graph.
type StaffMemberMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	name                    *string
	email                   *string
	password                *string
	role                    *staffmember.Role
	status                  *staffmember.Status
	clearedFields           map[string]struct{}
	processed_orders        map[int]struct{}
	removedprocessed_orders map[int]struct{}
	clearedprocessed_orders bool
	done                    bool
	oldValue                func(context.Context) (*StaffMember, error)
	predicates              []predicate.StaffMember
}

var _ ent.Mutation = (*StaffMemberMutation)(nil)

// staffmemberOption allows management of the mutation configuration using functional options.
type staffmemberOption func(*StaffMemberMutation)

// newStaffMemberMutation creates new mutation for the StaffMember entity.
func newStaffMemberMutation(c config, op Op, opts ...staffmemberOption) *StaffMemberMutation {
	m := &StaffMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeStaffMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaffMemberID sets the ID field of the mutation.
func withStaffMemberID(id int) staffmemberOption {
	return func(m *StaffMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *StaffMember
		)
		m.oldValue = func(ctx context.Context) (*StaffMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StaffMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaffMember sets the old StaffMember of the mutation.
func withStaffMember(node *StaffMember) staffmemberOption {
	return func(m *StaffMemberMutation) {
		m.oldValue = func(context.Context) (*StaffMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaffMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaffMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StaffMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StaffMemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StaffMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StaffMemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StaffMemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StaffMember entity.
// If the StaffMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StaffMemberMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *StaffMemberMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StaffMemberMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the StaffMember entity.
// If the StaffMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMemberMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *StaffMemberMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *StaffMemberMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *StaffMemberMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the StaffMember entity.
// If the StaffMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMemberMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *StaffMemberMutation) ResetPassword() {
	m.password = nil
}

// SetRole sets the "role" field.
func (m *StaffMemberMutation) SetRole(s staffmember.Role) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *StaffMemberMutation) Role() (r staffmember.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the StaffMember entity.
// If the StaffMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMemberMutation) OldRole(ctx context.Context) (v staffmember.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *StaffMemberMutation) ResetRole() {
	m.role = nil
}

// SetStatus sets the "status" field.
func (m *StaffMemberMutation) SetStatus(s staffmember.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StaffMemberMutation) Status() (r staffmember.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the StaffMember entity.
// If the StaffMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMemberMutation) OldStatus(ctx context.Context) (v staffmember.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StaffMemberMutation) ResetStatus() {
	m.status = nil
}

// AddProcessedOrderIDs adds the "processed_orders" edge to the Order entity by ids.
func (m *StaffMemberMutation) AddProcessedOrderIDs(ids ...int) {
	if m.processed_orders == nil {
		m.processed_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.processed_orders[ids[i]] = struct{}{}
	}
}

// ClearProcessedOrders clears the "processed_orders" edge to the Order entity.
func (m *StaffMemberMutation) ClearProcessedOrders() {
	m.clearedprocessed_orders = true
}

// ProcessedOrdersCleared reports if the "processed_orders" edge to the Order entity was cleared.
func (m *StaffMemberMutation) ProcessedOrdersCleared() bool {
	return m.clearedprocessed_orders
}

// RemoveProcessedOrderIDs removes the "processed_orders" edge to the Order entity by IDs.
func (m *StaffMemberMutation) RemoveProcessedOrderIDs(ids ...int) {
	if m.removedprocessed_orders == nil {
		m.removedprocessed_orders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.processed_orders, ids[i])
		m.removedprocessed_orders[ids[i]] = struct{}{}
	}
}

// RemovedProcessedOrders returns the removed IDs of the "processed_orders" edge to the Order entity.
func (m *StaffMemberMutation) RemovedProcessedOrdersIDs() (ids []int) {
	for id := range m.removedprocessed_orders {
		ids = append(ids, id)
	}
	return
}

// ProcessedOrdersIDs returns the "processed_orders" edge IDs in the mutation.
func (m *StaffMemberMutation) ProcessedOrdersIDs() (ids []int) {
	for id := range m.processed_orders {
		ids = append(ids, id)
	}
	return
}

// ResetProcessedOrders resets all changes to the "processed_orders" edge.
func (m *StaffMemberMutation) ResetProcessedOrders() {
	m.processed_orders = nil
	m.clearedprocessed_orders = false
	m.removedprocessed_orders = nil
}

// Where appends a list predicates to the StaffMemberMutation builder.
func (m *StaffMemberMutation) Where(ps ...predicate.StaffMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StaffMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StaffMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StaffMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StaffMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StaffMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StaffMember).
func (m *StaffMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StaffMemberMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, staffmember.FieldName)
	}
	if m.email != nil {
		fields = append(fields, staffmember.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, staffmember.FieldPassword)
	}
	if m.role != nil {
		fields = append(fields, staffmember.FieldRole)
	}
	if m.status != nil {
		fields = append(fields, staffmember.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StaffMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staffmember.FieldName:
		return m.Name()
	case staffmember.FieldEmail:
		return m.Email()
	case staffmember.FieldPassword:
		return m.Password()
	case staffmember.FieldRole:
		return m.Role()
	case staffmember.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StaffMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staffmember.FieldName:
		return m.OldName(ctx)
	case staffmember.FieldEmail:
		return m.OldEmail(ctx)
	case staffmember.FieldPassword:
		return m.OldPassword(ctx)
	case staffmember.FieldRole:
		return m.OldRole(ctx)
	case staffmember.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown StaffMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staffmember.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case staffmember.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case staffmember.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case staffmember.FieldRole:
		v, ok := value.(staffmember.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case staffmember.FieldStatus:
		v, ok := value.(staffmember.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown StaffMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StaffMemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StaffMemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StaffMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StaffMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StaffMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaffMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StaffMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StaffMemberMutation) ResetField(name string) error {
	switch name {
	case staffmember.FieldName:
		m.ResetName()
		return nil
	case staffmember.FieldEmail:
		m.ResetEmail()
		return nil
	case staffmember.FieldPassword:
		m.ResetPassword()
		return nil
	case staffmember.FieldRole:
		m.ResetRole()
		return nil
	case staffmember.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown StaffMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StaffMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.processed_orders != nil {
		edges = append(edges, staffmember.EdgeProcessedOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StaffMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staffmember.EdgeProcessedOrders:
		ids := make([]ent.Value, 0, len(m.processed_orders))
		for id := range m.processed_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StaffMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprocessed_orders != nil {
		edges = append(edges, staffmember.EdgeProcessedOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StaffMemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case staffmember.EdgeProcessedOrders:
		ids := make([]ent.Value, 0, len(m.removedprocessed_orders))
		for id := range m.removedprocessed_orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StaffMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprocessed_orders {
		edges = append(edges, staffmember.EdgeProcessedOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StaffMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case staffmember.EdgeProcessedOrders:
		return m.clearedprocessed_orders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StaffMemberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown StaffMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StaffMemberMutation) ResetEdge(name string) error {
	switch name {
	case staffmember.EdgeProcessedOrders:
		m.ResetProcessedOrders()
		return nil
	}
	return fmt.Errorf("unknown StaffMember edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name_first    *string
	name_surname  *string
	email         *string
	phone         *string
	password      *string
	verified      *bool
	created_at    *time.Time
	status        *user.Status
	clearedFields map[string]struct{}
	owner         map[int]struct{}
	removedowner  map[int]struct{}
	clearedowner  bool
	orders        map[int]struct{}
	removedorders map[int]struct{}
	clearedorders bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameFirst sets the "name_first" field.
func (m *UserMutation) SetNameFirst(s string) {
	m.name_first = &s
}

// NameFirst returns the value of the "name_first" field in the mutation.
func (m *UserMutation) NameFirst() (r string, exists bool) {
	v := m.name_first
	if v == nil {
		return
	}
	return *v, true
}

// OldNameFirst returns the old "name_first" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNameFirst(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameFirst: %w", err)
	}
	return oldValue.NameFirst, nil
}

// ResetNameFirst resets all changes to the "name_first" field.
func (m *UserMutation) ResetNameFirst() {
	m.name_first = nil
}

// SetNameSurname sets the "name_surname" field.
func (m *UserMutation) SetNameSurname(s string) {
	m.name_surname = &s
}

// NameSurname returns the value of the "name_surname" field in the mutation.
func (m *UserMutation) NameSurname() (r string, exists bool) {
	v := m.name_surname
	if v == nil {
		return
	}
	return *v, true
}

// OldNameSurname returns the old "name_surname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNameSurname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameSurname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameSurname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameSurname: %w", err)
	}
	return oldValue.NameSurname, nil
}

// ResetNameSurname resets all changes to the "name_surname" field.
func (m *UserMutation) ResetNameSurname() {
	m.name_surname = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetVerified sets the "verified" field.
func (m *UserMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *UserMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *UserMutation) ResetVerified() {
	m.verified = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// AddOwnerIDs adds the "owner" edge to the PasswordToken entity by ids.
func (m *UserMutation) AddOwnerIDs(ids ...int) {
	if m.owner == nil {
		m.owner = make(map[int]struct{})
	}
	for i := range ids {
		m.owner[ids[i]] = struct{}{}
	}
}

// ClearOwner clears the "owner" edge to the PasswordToken entity.
func (m *UserMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the PasswordToken entity was cleared.
func (m *UserMutation) OwnerCleared() bool {
	return m.clearedowner
}

// RemoveOwnerIDs removes the "owner" edge to the PasswordToken entity by IDs.
func (m *UserMutation) RemoveOwnerIDs(ids ...int) {
	if m.removedowner == nil {
		m.removedowner = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owner, ids[i])
		m.removedowner[ids[i]] = struct{}{}
	}
}

// RemovedOwner returns the removed IDs of the "owner" edge to the PasswordToken entity.
func (m *UserMutation) RemovedOwnerIDs() (ids []int) {
	for id := range m.removedowner {
		ids = append(ids, id)
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
func (m *UserMutation) OwnerIDs() (ids []int) {
	for id := range m.owner {
		ids = append(ids, id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *UserMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
	m.removedowner = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *UserMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *UserMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *UserMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *UserMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *UserMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *UserMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *UserMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name_first != nil {
		fields = append(fields, user.FieldNameFirst)
	}
	if m.name_surname != nil {
		fields = append(fields, user.FieldNameSurname)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.verified != nil {
		fields = append(fields, user.FieldVerified)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldNameFirst:
		return m.NameFirst()
	case user.FieldNameSurname:
		return m.NameSurname()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPassword:
		return m.Password()
	case user.FieldVerified:
		return m.Verified()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldNameFirst:
		return m.OldNameFirst(ctx)
	case user.FieldNameSurname:
		return m.OldNameSurname(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldVerified:
		return m.OldVerified(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldNameFirst:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameFirst(v)
		return nil
	case user.FieldNameSurname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameSurname(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldNameFirst:
		m.ResetNameFirst()
		return nil
	case user.FieldNameSurname:
		m.ResetNameSurname()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldVerified:
		m.ResetVerified()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, user.EdgeOwner)
	}
	if m.orders != nil {
		edges = append(edges, user.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.owner))
		for id := range m.owner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedowner != nil {
		edges = append(edges, user.EdgeOwner)
	}
	if m.removedorders != nil {
		edges = append(edges, user.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.removedowner))
		for id := range m.removedowner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, user.EdgeOwner)
	}
	if m.clearedorders {
		edges = append(edges, user.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOwner:
		return m.clearedowner
	case user.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOwner:
		m.ResetOwner()
		return nil
	case user.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
